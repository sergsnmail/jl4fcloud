Описание программного комплекса "Сетевое хранилище"

1. Состав
	1.1 КЛИЕНТ. Программа работаящая на ПК пользователя.
		Функциональные требования к клиенту:
		1. Обеспечивает передачу учетных данных для аутентификации и регистрации пользоватля на сторону сервера.
		2. Позволяет указать локальную директорию для выгрузки файлов, принадлежащих учетной записи пользователя, и хранящихся на сервере.
		3. Обеспечивает передачу файлов из локальной директории на серевер (синхронизация).

	1.2 СЕРВЕР. Программа работаящая на серере и обрабатывающая запросы клиентов.
		Функциональные тербования к серверной части:
		1. Обеспечивает аутентификацию и регистрайию пользователя на сервере.
		2. Реализует такое хранение файлов, которое обеспечит полную изоляцию между пользователями.
		3. Принимает и передает файлы по команде клиента.

2. Как организовать клиент-серверное взаимодействие?
	2.1 Взаимодействие между клиент и сервером осуществляется посредствам передачи сообщений от клиента серверу и наоборот.
		Возможные виды сообщений клиента и сервера:
			* Пинг сервера для проверки доступности.
			* Сообщение для аутентификации пользователя на сервере.
			* Сообщение для регистрации нового пользователя на сервере.
			* Сообщение для передачи или загрузки файла.

3. Как и в каком виде передавать файлы?
	Вариант 1. Сериализовать в JSON с метаданными. Поскольку JSON это строка, придется использовать Base64 для преобразования 
			   байтов в символы латинского алфавита, что увеличивает размер на 33% 
			   Пример:
					{
						"file_name" : "<имя файла с расширением>"
						"created_date" : "<дата создания>"
						"modified_data" : "<дата модификации>"						
						"local_path" : "<путь от корня локальной директории до файла>"
						"body" : "[Base64]"
					}
	Вариант 2. Использовать protobuf. (Вроде как лучше подходит для передачи двоичных данны.)
	Вариант 3. Использовать свой протокол для передачи файлов и метаданных на основе DataInputStream/DataOutputStream.
			   Пример (приблизительный):
					1. Передаем строку(и) с метаданными (String).
					2. Передаем размер файла (long)
					3. Передаем файл
					
4. Как пересылать большие файлы?
	Разбивать на пакеты фиксированного размера и передавать последовательно. При успешной передачи всех пакетов на сервер, собирать вместе.

5. Как пересылать служебные команды?
	5.1 Сериализовать в JSON объекты.

6. Что хранить в базе данных?
	В базе будет хранится:
		6.1 Учетные данные пользователей
		6.2 Метаинформация о файлах, и ссылка на местоположение в папке на сервере.
		
		Примерная схема таблиц БД:
		* Таблица учетных данных пользователей
		+----+--------------+-----------+---------------------+
		| id | created_date | user_name |hashed_user_password |
		+----+--------------+-----------+---------------------+
				
		* Таблица файлов (user_file):
		+----+---------+--------------+---------------+-----------+------------+---------------------+
		| id | user_id | created_date | modified_data | file_name | local_path | location_in_storage |
		+----+---------+--------------+---------------+-----------+------------+---------------------+
		где:
			* file_name - оригинальное имя файла
			* local_path - иерархия каталогов в локальной папке пользователя для данного файла. Такое решение предполагает, что у одного и того-же клиента на разных ПК, 
						  выгрузка файла будет осуществлятся в одну и ту-же иерархию каталогов.
			* location_in_storage - уникальное имя файла (UID), для хранения в локальных папках на сервере
		
		Тут нужно подумать, как равномерно распределить файлы по папкам, поскольку хранить все файлы в одной папке не правильно 
		с точки зрения производительности.	

7. Как передавать структуру каталогов/файлов?
	Не совсем понимаю в чем тут может возникнуть трудность, поэтому предполагаю пока самый простой вариант - передавать в виде строки (local_path) в теле JSON (см. Вариант 1 в п.3).	
	
8. Какую библиотеку использовать для сетевого взаимодействия: java.io, java.nio, Netty?
	Пока не определился, либо java.nio, либо Netty.


